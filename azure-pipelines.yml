Got it. No backend in code. We’ll keep **local state** and ignore the Terraform service connection. Your pipeline is already good for that setup.

Here are the final, drop-in Terraform files that work with your pipeline as-is (no backend block, module ref hard-coded, fixed types/ternaries).

# providers.tf

```hcl
terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  # No backend block -> local state
}

provider "aws" {
  region = var.aws_region
}
```

# s3.tf

```hcl
data "aws_canonical_user_id" "this" {}

locals {
  grants            = try(jsondecode(var.grant), var.grant)
  lower_bucket_name = lower(var.bucket_name)
}

module "s3" {
  # Hard-coded ref (no variables allowed in module.source)
  source = "git::https://samcado.visualstudio.com/DEVOPS_Platform_as_a_Service/_git/s3//terraform-3.1.0-s3-bucket?ref=refs/tags/4.2.0"

  bucket = local.lower_bucket_name

  versioning = {
    enabled = var.versioning_enabled
  }

  attach_policy                        = true
  force_destroy                        = var.force_destroy
  block_public_acls                    = var.block_public_acls
  block_public_policy                  = var.block_public_policy
  server_side_encryption_configuration = var.server_side_encryption_configuration
  policy                               = var.bucket_policy_json
  ignore_public_acls                   = var.ignore_public_acls
  lifecycle_rule                       = var.lifecycle_rule
  restrict_public_buckets              = var.restrict_public_buckets
  control_object_ownership             = var.control_object_ownership
  object_ownership                     = var.object_ownership
  object_lock_enabled                  = var.object_lock_enabled
  object_lock_configuration            = var.object_lock_configuration

  # cast boolean to string so tags stays map(string)
  tags = merge(
    {
      Name                       = local.lower_bucket_name
      continuous_backups_enabled = tostring(var.continuous_backups_enabled)
    },
    var.tags
  )
}

resource "aws_s3_bucket_acl" "this" {
  depends_on = [module.s3]

  # enable ACL only when ownership isn't enforced AND (acl provided OR grants list non-empty)
  count = var.object_ownership == "BucketOwnerEnforced"
    ? 0
    : (
        ((var.acl != null) && (var.acl != "null") && (var.acl != ""))
        || (length(local.grants) > 0)
      )
      ? 1
      : 0

  bucket                = module.s3.s3_bucket_id
  expected_bucket_owner = var.expected_bucket_owner

  # pass-through; supports wrappers that can’t send null
  acl = var.acl != null ? var.acl : null

  dynamic "access_control_policy" {
    for_each = length(local.grants) > 0 ? [true] : []

    content {
      dynamic "grant" {
        for_each = local.grants
        content {
          permission = grant.value.permission
          grantee {
            type          = grant.value.type
            id            = try(grant.value.id, null)
            uri           = try(grant.value.uri, null)
            email_address = try(grant.value.email, null)
          }
        }
      }

      owner {
        id           = try(var.owner["id"], data.aws_canonical_user_id.this.id)
        display_name = try(var.owner["display_name"], null)
      }
    }
  }
}
```

# variables.tf

Use exactly what you posted earlier (it’s fine). No changes required.

# dev.tfvars

Use exactly what you posted earlier (it’s fine). No changes required.

---

## Final pipeline nits (already handled)

* We’re using **local state** (no backend). Good.
* Module auth handled via PAT in `~/.netrc`.
* We `cd "$(Build.SourcesDirectory)/$(Build.Repository.Name)"` so Terraform runs where your `.tf` files are.

Run the pipeline now. If Terraform errors again, paste the next error block and I’ll fix that specific line in the Terraform—no backend changes, no service-connection gymnastics.
